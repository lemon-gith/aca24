/* Splay tree benchmark
 * 
 * Benchmark to support performance optimisation
 * of GCC's splay tree implementation.
 *
 * Splay trees are used in several places in the GNU C Compiler,
 * and also, to support runtime bounds checking, in the 
 * runtime system for the mudflap and miro features.
 *
 * Paul Kelly  Imperial College London  2008
 */

#include <stdio.h>
#include "test-config.h"
#include "bounds-splay-tree.h"
#include "gettimemicroseconds.h"

/* visit_fun: this helper function is called by the "foreach" 
 * function to visit each node and print it.
 */
int visit_print_fun (boundssplay_tree_node n, void *null)
{
  printf("Key: %d, Value: %d\n", n->key, n->value);
  return 0; /* to tell foreach not to stop */
}

void print_splaytree(boundssplay_tree st)
{
  printf("Splay tree contents:\n");
  boundssplay_tree_foreach (st, visit_print_fun, NULL);
  printf("--------\n");
}

/* random_walk: compute next key based on random walk
 */

long random_walk(long key, long delta_range, long key_range)
{
  long key_delta = (long) (__my_random() % delta_range);
  key += key_delta - (delta_range/2);
  key %= key_range;
  key = (key < 0 ? -key : key);

#ifdef PRINT 
  printf("key_delta = %d, key = %d\n", key_delta, key);
#endif

  return key;
}


int main( int argc, char**argv )
{
  if (argc <= 1) {
    fprintf(stderr, "Usage: %s 1 (for testing)\n", argv[0]);
    fprintf(stderr, "Usage: %s 2 <NUM> <RANGE> (for performance test with tree containing <NUM> iterations with keys 0..<RANGE>-1)\n", argv[0]);
    fprintf(stderr, "Usage: %s 3 <NINS> <NITS> <KRANGE> <KDELTARANGE>\n", argv[0]);
    fprintf(stderr, "       (performance test with tree containing <NINS> insertions, queried <NITS> times, with keys 0..<RANGE>-1\n");
    fprintf(stderr, "        with keys generated by random walk with delta uniformly chosen from +/- <KDELTARANGE>/2)\n");
    exit(1);
  }

  switch(argv[1][0]) {
  case '1':
    {
      boundssplay_tree st = boundssplay_tree_new ();
      long i;
      
      for (i=0; i<100; ++i){
	long insert_key = (long) (__my_random() % 10001);
	long value = (long) __my_random() % 100;
	long lookup_key;
	long remove_key;
	boundssplay_tree_node n;

	printf("Insertion - key: %d, value: %d\n", insert_key, value);
	boundssplay_tree_insert (st, (boundssplay_tree_key)insert_key, (boundssplay_tree_value)value);
	
	lookup_key = (long) (__my_random() % 10000);
	n = boundssplay_tree_lookup (st, (boundssplay_tree_key)lookup_key);
	if (n != NULL) {
	  printf("Lookup - match found at: %d, Value: %d\n", n->key, n->value);
	} else {
	  printf("Lookup - no match for key: %d\n", lookup_key);
	}

	remove_key = (long) (__my_random() % 10000);
	boundssplay_tree_remove (st, (boundssplay_tree_key)remove_key);
      }
      print_splaytree(st);
      break;
    }

  case '2':
    {
      long number_of_iterations = atoi(argv[2]);

      long key_range = atoi(argv[3]);

      boundssplay_tree st = boundssplay_tree_new ();
      long i;
      long number_of_matches = 0;
      boundssplay_tree_node n;

      printf("Performing %d random insertions, random queries and random deletions with key range %d\n", number_of_iterations, key_range);
      
      for (i=0; i<number_of_iterations; ++i){
	long insert_key = (long) (__my_random() % key_range);
	long value = (long) __my_random() % 100;
	long lookup_key = (long) (__my_random() % key_range);
	long remove_key = (long) (__my_random() % key_range);
	
	boundssplay_tree_insert (st, (boundssplay_tree_key)insert_key, (boundssplay_tree_value)value);
	
	n = boundssplay_tree_lookup (st, (boundssplay_tree_key)lookup_key);
	if (n != NULL) {
	  number_of_matches += 1;
	} 

	boundssplay_tree_remove (st, (boundssplay_tree_key)remove_key);
      }
      /*      print_splaytree(st); */

      printf("number_of_matches = %d\n", number_of_matches);
      break;
    }

  case '3':
    {
      unsigned long lasttime;
      unsigned long gettimemicroseconds();

      long number_of_insertions = atoi(argv[2]);

      long number_of_queries = atoi(argv[3]);

      long key_range = atoi(argv[4]);

      long key_delta_range = atoi(argv[5]);

      boundssplay_tree st = boundssplay_tree_new ();
      long i;
      long insert_key = 0;
      long lookup_key;
      long number_of_matches;
      long query_time;
      lasttime = gettimemicroseconds();  /* Start timer */

      /* First build the tree by inserting <NINS> items, using keys generated by random walk */

      printf("Performing %d insertions with keys generated by random walk\n", number_of_insertions);

      for (i=0; i<number_of_insertions; ++i){
	long value = (long) __my_random() % 100;

	insert_key = random_walk(insert_key, key_delta_range, key_range);

#ifdef PRINT 
	printf("insert_key = %d, value = %d\n", insert_key, value);
#endif
	
	boundssplay_tree_insert (st, (boundssplay_tree_key)insert_key, (boundssplay_tree_value)value);
      }

      printf("Insertions: %ld microseconds\n", gettimemicroseconds()-lasttime);
      lasttime = gettimemicroseconds();

      /* Now query the tree, <NITS> times, using keys generated by random walk */

      printf("Performing %d queries\n", number_of_queries);

      lookup_key = 0;

      number_of_matches = 0;

      for (i=0; i<number_of_queries; ++i){
	boundssplay_tree_node n;

	lookup_key = random_walk(lookup_key, key_delta_range, key_range);

	n = boundssplay_tree_lookup (st, (boundssplay_tree_key)lookup_key);
	if (n != NULL) {
	  number_of_matches += 1;
	} 
      }
      query_time = gettimemicroseconds()-lasttime;
      printf("Queries: %ld microseconds, %f microseconds/query\n", query_time, ((double)query_time)/number_of_queries);
      lasttime = gettimemicroseconds();

      /*      print_splaytree(st); */

      printf("number_of_matches = %d\n", number_of_matches);
      break;
    }
  default:
    printf("Invalid test number\n");
  }
}


